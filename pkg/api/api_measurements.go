/*
Sensorbucket API

SensorBucket processes data from different sources and devices into a single standardized format.  An applications connected to SensorBucket, can use all devices SensorBucket supports.  Missing a device or source? SensorBucket is designed to be scalable and extendable. Create your own worker that receives data from an AMQP source, process said data and output in the expected worker output format.  Find out more at: https://developer.sensorbucket.nl/  Developed and designed by Provincie Zeeland and Pollex 

API version: 1.0
Contact: info@pollex.nl
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// MeasurementsApiService MeasurementsApi service
type MeasurementsApiService service

type ApiGetDatastreamRequest struct {
	ctx context.Context
	ApiService *MeasurementsApiService
	id string
}

func (r ApiGetDatastreamRequest) Execute() (*GetDatastream200Response, *http.Response, error) {
	return r.ApiService.GetDatastreamExecute(r)
}

/*
GetDatastream Get datastream

Get the datastream with the given identifier.

The returned datastream will also include the full model of the sensors attached to that datastream.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The UUID of the datastream
 @return ApiGetDatastreamRequest
*/
func (a *MeasurementsApiService) GetDatastream(ctx context.Context, id string) ApiGetDatastreamRequest {
	return ApiGetDatastreamRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetDatastream200Response
func (a *MeasurementsApiService) GetDatastreamExecute(r ApiGetDatastreamRequest) (*GetDatastream200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatastream200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeasurementsApiService.GetDatastream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datastreams/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatastreamsRequest struct {
	ctx context.Context
	ApiService *MeasurementsApiService
	sensor *[]int32
	cursor *string
	limit *float32
}

// only return datastreams that are produced by the given sensor identifier
func (r ApiListDatastreamsRequest) Sensor(sensor []int32) ApiListDatastreamsRequest {
	r.sensor = &sensor
	return r
}

// The cursor for the current page
func (r ApiListDatastreamsRequest) Cursor(cursor string) ApiListDatastreamsRequest {
	r.cursor = &cursor
	return r
}

// The maximum amount of items per page. Not applicable if &#x60;cursor&#x60; parameter is given. System limits are in place. 
func (r ApiListDatastreamsRequest) Limit(limit float32) ApiListDatastreamsRequest {
	r.limit = &limit
	return r
}

func (r ApiListDatastreamsRequest) Execute() (*ListDatastreams200Response, *http.Response, error) {
	return r.ApiService.ListDatastreamsExecute(r)
}

/*
ListDatastreams List all datastreams

List all datastreams.

A sensor can produce one or more timeseries of measurements. Such a unique timeserie is called a datastream.  

**For example:** A Particulate Matter sensor might return count the number of particles smaller than 2.5 μg/cm2, 5 μg/cm2 and 10 μg/cm2.
this is one sensor producing three datastreams.

Another example would be a worker which processes raw incoming values into meaningful data.
An underwater pressure sensor might supply its measurement in milli Amperes, but the worker converts it to watercolumn in meters.
The sensor now has two datastreams. Presusre in millivolt and watercolumn in meters.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatastreamsRequest
*/
func (a *MeasurementsApiService) ListDatastreams(ctx context.Context) ApiListDatastreamsRequest {
	return ApiListDatastreamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDatastreams200Response
func (a *MeasurementsApiService) ListDatastreamsExecute(r ApiListDatastreamsRequest) (*ListDatastreams200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDatastreams200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeasurementsApiService.ListDatastreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/datastreams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sensor != nil {
		t := *r.sensor
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("sensor", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("sensor", parameterToString(t, "multi"))
		}
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryMeasurementsRequest struct {
	ctx context.Context
	ApiService *MeasurementsApiService
	start *time.Time
	end *time.Time
	deviceId *string
	datastream *string
	sensorCode *string
	cursor *string
	limit *float32
}

func (r ApiQueryMeasurementsRequest) Start(start time.Time) ApiQueryMeasurementsRequest {
	r.start = &start
	return r
}

func (r ApiQueryMeasurementsRequest) End(end time.Time) ApiQueryMeasurementsRequest {
	r.end = &end
	return r
}

func (r ApiQueryMeasurementsRequest) DeviceId(deviceId string) ApiQueryMeasurementsRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiQueryMeasurementsRequest) Datastream(datastream string) ApiQueryMeasurementsRequest {
	r.datastream = &datastream
	return r
}

func (r ApiQueryMeasurementsRequest) SensorCode(sensorCode string) ApiQueryMeasurementsRequest {
	r.sensorCode = &sensorCode
	return r
}

// The cursor for the current page
func (r ApiQueryMeasurementsRequest) Cursor(cursor string) ApiQueryMeasurementsRequest {
	r.cursor = &cursor
	return r
}

// The maximum amount of items per page. Not applicable if &#x60;cursor&#x60; parameter is given. System limits are in place. 
func (r ApiQueryMeasurementsRequest) Limit(limit float32) ApiQueryMeasurementsRequest {
	r.limit = &limit
	return r
}

func (r ApiQueryMeasurementsRequest) Execute() (*QueryMeasurements200Response, *http.Response, error) {
	return r.ApiService.QueryMeasurementsExecute(r)
}

/*
QueryMeasurements Query measurements

Query a list of measurements.

This endpoint is used to get all measurements that correspond with the given filters.

It is commonly required to get a single stream of measurements from a single sensor. This can be accomplished by 
finding the corresponding datastream ID and using that in the `datastream` filter. 

Most query parameters can be repeated to get an OR combination of filters. For example, providing the `datastream` 
parameter twice will return measurements for either datastreams.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryMeasurementsRequest
*/
func (a *MeasurementsApiService) QueryMeasurements(ctx context.Context) ApiQueryMeasurementsRequest {
	return ApiQueryMeasurementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QueryMeasurements200Response
func (a *MeasurementsApiService) QueryMeasurementsExecute(r ApiQueryMeasurementsRequest) (*QueryMeasurements200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryMeasurements200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeasurementsApiService.QueryMeasurements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/measurements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.deviceId != nil {
		localVarQueryParams.Add("device_id", parameterToString(*r.deviceId, ""))
	}
	if r.datastream != nil {
		localVarQueryParams.Add("datastream", parameterToString(*r.datastream, ""))
	}
	if r.sensorCode != nil {
		localVarQueryParams.Add("sensor_code", parameterToString(*r.sensorCode, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Sensorbucket API

SensorBucket processes data from different sources and devices into a single standardized format.  An applications connected to SensorBucket, can use all devices SensorBucket supports.  Missing a device or source? SensorBucket is designed to be scalable and extendable. Create your own worker that receives data from an AMQP source, process said data and output in the expected worker output format.  Find out more at: https://developer.sensorbucket.nl/  Developed and designed by Provincie Zeeland and Pollex 

API version: 1.0
Contact: info@pollex.nl
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// UplinkApiService UplinkApi service
type UplinkApiService service

type ApiProcessUplinkDataRequest struct {
	ctx context.Context
	ApiService *UplinkApiService
	pipelineId string
	body *map[string]interface{}
}

func (r ApiProcessUplinkDataRequest) Body(body map[string]interface{}) ApiProcessUplinkDataRequest {
	r.body = &body
	return r
}

func (r ApiProcessUplinkDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.ProcessUplinkDataExecute(r)
}

/*
ProcessUplinkData Process uplink message

Push an uplink message to the HTTP Importer for processing.

The request body and content-type can be anything the workers (defined by the pipeline steps) in the pipeline expect.

As this process is asynchronuous, any processing error will not be returned in the response.
Only if the HTTP Importer is unable to push the message to the Message Queue, will an error be returned. 


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pipelineId The UUID of the pipeline
 @return ApiProcessUplinkDataRequest
*/
func (a *UplinkApiService) ProcessUplinkData(ctx context.Context, pipelineId string) ApiProcessUplinkDataRequest {
	return ApiProcessUplinkDataRequest{
		ApiService: a,
		ctx: ctx,
		pipelineId: pipelineId,
	}
}

// Execute executes the request
func (a *UplinkApiService) ProcessUplinkDataExecute(r ApiProcessUplinkDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UplinkApiService.ProcessUplinkData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uplinks/{pipeline_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pipeline_id"+"}", url.PathEscape(parameterToString(r.pipelineId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

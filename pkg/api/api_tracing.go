/*
Sensorbucket API

SensorBucket processes data from different sources and devices into a single standardized format.  An applications connected to SensorBucket, can use all devices SensorBucket supports.  Missing a device or source? SensorBucket is designed to be scalable and extendable. Create your own worker that receives data from an AMQP source, process said data and output in the expected worker output format.  Find out more at: https://developer.sensorbucket.nl/  Developed and designed by Provincie Zeeland and Pollex 

API version: 1.0
Contact: info@pollex.nl
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
    "sensorbucket.nl/sensorbucket/internal/web"
)


// TracingApiService TracingApi service
type TracingApiService service

type ApiListTracesRequest struct {
	ctx context.Context
	ApiService *TracingApiService
	cursor *string
	limit *float32
	tracingId *[]string
	deviceId *int64
	status *int32
	durationGreaterThan *string
	durationSmallerThan *string
}

// The cursor for the current page
func (r ApiListTracesRequest) Cursor(cursor string) ApiListTracesRequest {
	r.cursor = &cursor
	return r
}

// The maximum amount of items per page. Not applicable if &#x60;cursor&#x60; parameter is given. System limits are in place. 
func (r ApiListTracesRequest) Limit(limit float32) ApiListTracesRequest {
	r.limit = &limit
	return r
}

func (r ApiListTracesRequest) TracingId(tracingId []string) ApiListTracesRequest {
	r.tracingId = &tracingId
	return r
}

func (r ApiListTracesRequest) DeviceId(deviceId int64) ApiListTracesRequest {
	r.deviceId = &deviceId
	return r
}

func (r ApiListTracesRequest) Status(status int32) ApiListTracesRequest {
	r.status = &status
	return r
}

func (r ApiListTracesRequest) DurationGreaterThan(durationGreaterThan string) ApiListTracesRequest {
	r.durationGreaterThan = &durationGreaterThan
	return r
}

func (r ApiListTracesRequest) DurationSmallerThan(durationSmallerThan string) ApiListTracesRequest {
	r.durationSmallerThan = &durationSmallerThan
	return r
}

func (r ApiListTracesRequest) Execute() (*ListTraces200Response, *http.Response, error) {
	return r.ApiService.ListTracesExecute(r)
}

/*
ListTraces List traces

Lists traces that match the provided filter.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTracesRequest
*/
func (a *TracingApiService) ListTraces(ctx context.Context) ApiListTracesRequest {
	return ApiListTracesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTraces200Response
func (a *TracingApiService) ListTracesExecute(r ApiListTracesRequest) (*ListTraces200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTraces200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracingApiService.ListTraces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.tracingId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tracing_id", r.tracingId, "csv")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_id", r.deviceId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.durationGreaterThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_greater_than", r.durationGreaterThan, "")
	}
	if r.durationSmallerThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_smaller_than", r.durationSmallerThan, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
        var newErr *web.APIError
        err = a.client.decode(&newErr, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
        if err != nil {
            return localVarReturnValue, localVarHTTPResponse, err
        }
        newErr.HTTPStatus = localVarHTTPResponse.StatusCode
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

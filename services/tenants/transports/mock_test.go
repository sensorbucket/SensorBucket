// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package tenantstransports_test

import (
	"sensorbucket.nl/sensorbucket/internal/pagination"
	"sensorbucket.nl/sensorbucket/pkg/auth"
	"sensorbucket.nl/sensorbucket/services/tenants/apikeys"
	"sensorbucket.nl/sensorbucket/services/tenants/tenants"
	"sensorbucket.nl/sensorbucket/services/tenants/transports"
	"sync"
	"time"
)

// Ensure, that ApiKeyServiceMock does implement tenantstransports.ApiKeyService.
// If this is not the case, regenerate this file with moq.
var _ tenantstransports.ApiKeyService = &ApiKeyServiceMock{}

// ApiKeyServiceMock is a mock implementation of tenantstransports.ApiKeyService.
//
//	func TestSomethingThatUsesApiKeyService(t *testing.T) {
//
//		// make and configure a mocked tenantstransports.ApiKeyService
//		mockedApiKeyService := &ApiKeyServiceMock{
//			AuthenticateApiKeyFunc: func(base64IdAndKeyCombination string) (apikeys.ApiKeyAuthenticationDTO, error) {
//				panic("mock out the AuthenticateApiKey method")
//			},
//			GenerateNewApiKeyFunc: func(name string, tenantId int64, permissions auth.Permissions, expiry *time.Time) (string, error) {
//				panic("mock out the GenerateNewApiKey method")
//			},
//			ListAPIKeysFunc: func(filter apikeys.Filter, p pagination.Request) (*pagination.Page[apikeys.ApiKeyDTO], error) {
//				panic("mock out the ListAPIKeys method")
//			},
//			RevokeApiKeyFunc: func(id int64) error {
//				panic("mock out the RevokeApiKey method")
//			},
//		}
//
//		// use mockedApiKeyService in code that requires tenantstransports.ApiKeyService
//		// and then make assertions.
//
//	}
type ApiKeyServiceMock struct {
	// AuthenticateApiKeyFunc mocks the AuthenticateApiKey method.
	AuthenticateApiKeyFunc func(base64IdAndKeyCombination string) (apikeys.ApiKeyAuthenticationDTO, error)

	// GenerateNewApiKeyFunc mocks the GenerateNewApiKey method.
	GenerateNewApiKeyFunc func(name string, tenantId int64, permissions auth.Permissions, expiry *time.Time) (string, error)

	// ListAPIKeysFunc mocks the ListAPIKeys method.
	ListAPIKeysFunc func(filter apikeys.Filter, p pagination.Request) (*pagination.Page[apikeys.ApiKeyDTO], error)

	// RevokeApiKeyFunc mocks the RevokeApiKey method.
	RevokeApiKeyFunc func(id int64) error

	// calls tracks calls to the methods.
	calls struct {
		// AuthenticateApiKey holds details about calls to the AuthenticateApiKey method.
		AuthenticateApiKey []struct {
			// Base64IdAndKeyCombination is the base64IdAndKeyCombination argument value.
			Base64IdAndKeyCombination string
		}
		// GenerateNewApiKey holds details about calls to the GenerateNewApiKey method.
		GenerateNewApiKey []struct {
			// Name is the name argument value.
			Name string
			// TenantId is the tenantId argument value.
			TenantId int64
			// Permissions is the permissions argument value.
			Permissions auth.Permissions
			// Expiry is the expiry argument value.
			Expiry *time.Time
		}
		// ListAPIKeys holds details about calls to the ListAPIKeys method.
		ListAPIKeys []struct {
			// Filter is the filter argument value.
			Filter apikeys.Filter
			// P is the p argument value.
			P pagination.Request
		}
		// RevokeApiKey holds details about calls to the RevokeApiKey method.
		RevokeApiKey []struct {
			// ID is the id argument value.
			ID int64
		}
	}
	lockAuthenticateApiKey sync.RWMutex
	lockGenerateNewApiKey  sync.RWMutex
	lockListAPIKeys        sync.RWMutex
	lockRevokeApiKey       sync.RWMutex
}

// AuthenticateApiKey calls AuthenticateApiKeyFunc.
func (mock *ApiKeyServiceMock) AuthenticateApiKey(base64IdAndKeyCombination string) (apikeys.ApiKeyAuthenticationDTO, error) {
	if mock.AuthenticateApiKeyFunc == nil {
		panic("ApiKeyServiceMock.AuthenticateApiKeyFunc: method is nil but ApiKeyService.AuthenticateApiKey was just called")
	}
	callInfo := struct {
		Base64IdAndKeyCombination string
	}{
		Base64IdAndKeyCombination: base64IdAndKeyCombination,
	}
	mock.lockAuthenticateApiKey.Lock()
	mock.calls.AuthenticateApiKey = append(mock.calls.AuthenticateApiKey, callInfo)
	mock.lockAuthenticateApiKey.Unlock()
	return mock.AuthenticateApiKeyFunc(base64IdAndKeyCombination)
}

// AuthenticateApiKeyCalls gets all the calls that were made to AuthenticateApiKey.
// Check the length with:
//
//	len(mockedApiKeyService.AuthenticateApiKeyCalls())
func (mock *ApiKeyServiceMock) AuthenticateApiKeyCalls() []struct {
	Base64IdAndKeyCombination string
} {
	var calls []struct {
		Base64IdAndKeyCombination string
	}
	mock.lockAuthenticateApiKey.RLock()
	calls = mock.calls.AuthenticateApiKey
	mock.lockAuthenticateApiKey.RUnlock()
	return calls
}

// GenerateNewApiKey calls GenerateNewApiKeyFunc.
func (mock *ApiKeyServiceMock) GenerateNewApiKey(name string, tenantId int64, permissions auth.Permissions, expiry *time.Time) (string, error) {
	if mock.GenerateNewApiKeyFunc == nil {
		panic("ApiKeyServiceMock.GenerateNewApiKeyFunc: method is nil but ApiKeyService.GenerateNewApiKey was just called")
	}
	callInfo := struct {
		Name        string
		TenantId    int64
		Permissions auth.Permissions
		Expiry      *time.Time
	}{
		Name:        name,
		TenantId:    tenantId,
		Permissions: permissions,
		Expiry:      expiry,
	}
	mock.lockGenerateNewApiKey.Lock()
	mock.calls.GenerateNewApiKey = append(mock.calls.GenerateNewApiKey, callInfo)
	mock.lockGenerateNewApiKey.Unlock()
	return mock.GenerateNewApiKeyFunc(name, tenantId, permissions, expiry)
}

// GenerateNewApiKeyCalls gets all the calls that were made to GenerateNewApiKey.
// Check the length with:
//
//	len(mockedApiKeyService.GenerateNewApiKeyCalls())
func (mock *ApiKeyServiceMock) GenerateNewApiKeyCalls() []struct {
	Name        string
	TenantId    int64
	Permissions auth.Permissions
	Expiry      *time.Time
} {
	var calls []struct {
		Name        string
		TenantId    int64
		Permissions auth.Permissions
		Expiry      *time.Time
	}
	mock.lockGenerateNewApiKey.RLock()
	calls = mock.calls.GenerateNewApiKey
	mock.lockGenerateNewApiKey.RUnlock()
	return calls
}

// ListAPIKeys calls ListAPIKeysFunc.
func (mock *ApiKeyServiceMock) ListAPIKeys(filter apikeys.Filter, p pagination.Request) (*pagination.Page[apikeys.ApiKeyDTO], error) {
	if mock.ListAPIKeysFunc == nil {
		panic("ApiKeyServiceMock.ListAPIKeysFunc: method is nil but ApiKeyService.ListAPIKeys was just called")
	}
	callInfo := struct {
		Filter apikeys.Filter
		P      pagination.Request
	}{
		Filter: filter,
		P:      p,
	}
	mock.lockListAPIKeys.Lock()
	mock.calls.ListAPIKeys = append(mock.calls.ListAPIKeys, callInfo)
	mock.lockListAPIKeys.Unlock()
	return mock.ListAPIKeysFunc(filter, p)
}

// ListAPIKeysCalls gets all the calls that were made to ListAPIKeys.
// Check the length with:
//
//	len(mockedApiKeyService.ListAPIKeysCalls())
func (mock *ApiKeyServiceMock) ListAPIKeysCalls() []struct {
	Filter apikeys.Filter
	P      pagination.Request
} {
	var calls []struct {
		Filter apikeys.Filter
		P      pagination.Request
	}
	mock.lockListAPIKeys.RLock()
	calls = mock.calls.ListAPIKeys
	mock.lockListAPIKeys.RUnlock()
	return calls
}

// RevokeApiKey calls RevokeApiKeyFunc.
func (mock *ApiKeyServiceMock) RevokeApiKey(id int64) error {
	if mock.RevokeApiKeyFunc == nil {
		panic("ApiKeyServiceMock.RevokeApiKeyFunc: method is nil but ApiKeyService.RevokeApiKey was just called")
	}
	callInfo := struct {
		ID int64
	}{
		ID: id,
	}
	mock.lockRevokeApiKey.Lock()
	mock.calls.RevokeApiKey = append(mock.calls.RevokeApiKey, callInfo)
	mock.lockRevokeApiKey.Unlock()
	return mock.RevokeApiKeyFunc(id)
}

// RevokeApiKeyCalls gets all the calls that were made to RevokeApiKey.
// Check the length with:
//
//	len(mockedApiKeyService.RevokeApiKeyCalls())
func (mock *ApiKeyServiceMock) RevokeApiKeyCalls() []struct {
	ID int64
} {
	var calls []struct {
		ID int64
	}
	mock.lockRevokeApiKey.RLock()
	calls = mock.calls.RevokeApiKey
	mock.lockRevokeApiKey.RUnlock()
	return calls
}

// Ensure, that TenantServiceMock does implement tenantstransports.TenantService.
// If this is not the case, regenerate this file with moq.
var _ tenantstransports.TenantService = &TenantServiceMock{}

// TenantServiceMock is a mock implementation of tenantstransports.TenantService.
//
//	func TestSomethingThatUsesTenantService(t *testing.T) {
//
//		// make and configure a mocked tenantstransports.TenantService
//		mockedTenantService := &TenantServiceMock{
//			ArchiveTenantFunc: func(tenantID int64) error {
//				panic("mock out the ArchiveTenant method")
//			},
//			CreateNewTenantFunc: func(tenant tenants.TenantDTO) (tenants.TenantDTO, error) {
//				panic("mock out the CreateNewTenant method")
//			},
//			ListTenantsFunc: func(filter tenants.Filter, p pagination.Request) (*pagination.Page[tenants.TenantDTO], error) {
//				panic("mock out the ListTenants method")
//			},
//		}
//
//		// use mockedTenantService in code that requires tenantstransports.TenantService
//		// and then make assertions.
//
//	}
type TenantServiceMock struct {
	// ArchiveTenantFunc mocks the ArchiveTenant method.
	ArchiveTenantFunc func(tenantID int64) error

	// CreateNewTenantFunc mocks the CreateNewTenant method.
	CreateNewTenantFunc func(tenant tenants.TenantDTO) (tenants.TenantDTO, error)

	// ListTenantsFunc mocks the ListTenants method.
	ListTenantsFunc func(filter tenants.Filter, p pagination.Request) (*pagination.Page[tenants.TenantDTO], error)

	// calls tracks calls to the methods.
	calls struct {
		// ArchiveTenant holds details about calls to the ArchiveTenant method.
		ArchiveTenant []struct {
			// TenantID is the tenantID argument value.
			TenantID int64
		}
		// CreateNewTenant holds details about calls to the CreateNewTenant method.
		CreateNewTenant []struct {
			// Tenant is the tenant argument value.
			Tenant tenants.TenantDTO
		}
		// ListTenants holds details about calls to the ListTenants method.
		ListTenants []struct {
			// Filter is the filter argument value.
			Filter tenants.Filter
			// P is the p argument value.
			P pagination.Request
		}
	}
	lockArchiveTenant   sync.RWMutex
	lockCreateNewTenant sync.RWMutex
	lockListTenants     sync.RWMutex
}

// ArchiveTenant calls ArchiveTenantFunc.
func (mock *TenantServiceMock) ArchiveTenant(tenantID int64) error {
	if mock.ArchiveTenantFunc == nil {
		panic("TenantServiceMock.ArchiveTenantFunc: method is nil but TenantService.ArchiveTenant was just called")
	}
	callInfo := struct {
		TenantID int64
	}{
		TenantID: tenantID,
	}
	mock.lockArchiveTenant.Lock()
	mock.calls.ArchiveTenant = append(mock.calls.ArchiveTenant, callInfo)
	mock.lockArchiveTenant.Unlock()
	return mock.ArchiveTenantFunc(tenantID)
}

// ArchiveTenantCalls gets all the calls that were made to ArchiveTenant.
// Check the length with:
//
//	len(mockedTenantService.ArchiveTenantCalls())
func (mock *TenantServiceMock) ArchiveTenantCalls() []struct {
	TenantID int64
} {
	var calls []struct {
		TenantID int64
	}
	mock.lockArchiveTenant.RLock()
	calls = mock.calls.ArchiveTenant
	mock.lockArchiveTenant.RUnlock()
	return calls
}

// CreateNewTenant calls CreateNewTenantFunc.
func (mock *TenantServiceMock) CreateNewTenant(tenant tenants.TenantDTO) (tenants.TenantDTO, error) {
	if mock.CreateNewTenantFunc == nil {
		panic("TenantServiceMock.CreateNewTenantFunc: method is nil but TenantService.CreateNewTenant was just called")
	}
	callInfo := struct {
		Tenant tenants.TenantDTO
	}{
		Tenant: tenant,
	}
	mock.lockCreateNewTenant.Lock()
	mock.calls.CreateNewTenant = append(mock.calls.CreateNewTenant, callInfo)
	mock.lockCreateNewTenant.Unlock()
	return mock.CreateNewTenantFunc(tenant)
}

// CreateNewTenantCalls gets all the calls that were made to CreateNewTenant.
// Check the length with:
//
//	len(mockedTenantService.CreateNewTenantCalls())
func (mock *TenantServiceMock) CreateNewTenantCalls() []struct {
	Tenant tenants.TenantDTO
} {
	var calls []struct {
		Tenant tenants.TenantDTO
	}
	mock.lockCreateNewTenant.RLock()
	calls = mock.calls.CreateNewTenant
	mock.lockCreateNewTenant.RUnlock()
	return calls
}

// ListTenants calls ListTenantsFunc.
func (mock *TenantServiceMock) ListTenants(filter tenants.Filter, p pagination.Request) (*pagination.Page[tenants.TenantDTO], error) {
	if mock.ListTenantsFunc == nil {
		panic("TenantServiceMock.ListTenantsFunc: method is nil but TenantService.ListTenants was just called")
	}
	callInfo := struct {
		Filter tenants.Filter
		P      pagination.Request
	}{
		Filter: filter,
		P:      p,
	}
	mock.lockListTenants.Lock()
	mock.calls.ListTenants = append(mock.calls.ListTenants, callInfo)
	mock.lockListTenants.Unlock()
	return mock.ListTenantsFunc(filter, p)
}

// ListTenantsCalls gets all the calls that were made to ListTenants.
// Check the length with:
//
//	len(mockedTenantService.ListTenantsCalls())
func (mock *TenantServiceMock) ListTenantsCalls() []struct {
	Filter tenants.Filter
	P      pagination.Request
} {
	var calls []struct {
		Filter tenants.Filter
		P      pagination.Request
	}
	mock.lockListTenants.RLock()
	calls = mock.calls.ListTenants
	mock.lockListTenants.RUnlock()
	return calls
}

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package processing_test

import (
	"sensorbucket.nl/sensorbucket/internal/pagination"
	"sensorbucket.nl/sensorbucket/services/core/processing"
	"sync"
)

// Ensure, that StoreMock does implement processing.Store.
// If this is not the case, regenerate this file with moq.
var _ processing.Store = &StoreMock{}

// StoreMock is a mock implementation of processing.Store.
//
//	func TestSomethingThatUsesStore(t *testing.T) {
//
//		// make and configure a mocked processing.Store
//		mockedStore := &StoreMock{
//			CreatePipelineFunc: func(pipeline *processing.Pipeline) error {
//				panic("mock out the CreatePipeline method")
//			},
//			GetPipelineFunc: func(s string) (*processing.Pipeline, error) {
//				panic("mock out the GetPipeline method")
//			},
//			ListPipelinesFunc: func(pipelinesFilter processing.PipelinesFilter, request pagination.Request) (pagination.Page[processing.Pipeline], error) {
//				panic("mock out the ListPipelines method")
//			},
//			UpdatePipelineFunc: func(pipeline *processing.Pipeline) error {
//				panic("mock out the UpdatePipeline method")
//			},
//		}
//
//		// use mockedStore in code that requires processing.Store
//		// and then make assertions.
//
//	}
type StoreMock struct {
	// CreatePipelineFunc mocks the CreatePipeline method.
	CreatePipelineFunc func(pipeline *processing.Pipeline) error

	// GetPipelineFunc mocks the GetPipeline method.
	GetPipelineFunc func(s string) (*processing.Pipeline, error)

	// ListPipelinesFunc mocks the ListPipelines method.
	ListPipelinesFunc func(pipelinesFilter processing.PipelinesFilter, request pagination.Request) (pagination.Page[processing.Pipeline], error)

	// UpdatePipelineFunc mocks the UpdatePipeline method.
	UpdatePipelineFunc func(pipeline *processing.Pipeline) error

	// calls tracks calls to the methods.
	calls struct {
		// CreatePipeline holds details about calls to the CreatePipeline method.
		CreatePipeline []struct {
			// Pipeline is the pipeline argument value.
			Pipeline *processing.Pipeline
		}
		// GetPipeline holds details about calls to the GetPipeline method.
		GetPipeline []struct {
			// S is the s argument value.
			S string
		}
		// ListPipelines holds details about calls to the ListPipelines method.
		ListPipelines []struct {
			// PipelinesFilter is the pipelinesFilter argument value.
			PipelinesFilter processing.PipelinesFilter
			// Request is the request argument value.
			Request pagination.Request
		}
		// UpdatePipeline holds details about calls to the UpdatePipeline method.
		UpdatePipeline []struct {
			// Pipeline is the pipeline argument value.
			Pipeline *processing.Pipeline
		}
	}
	lockCreatePipeline sync.RWMutex
	lockGetPipeline    sync.RWMutex
	lockListPipelines  sync.RWMutex
	lockUpdatePipeline sync.RWMutex
}

// CreatePipeline calls CreatePipelineFunc.
func (mock *StoreMock) CreatePipeline(pipeline *processing.Pipeline) error {
	if mock.CreatePipelineFunc == nil {
		panic("StoreMock.CreatePipelineFunc: method is nil but Store.CreatePipeline was just called")
	}
	callInfo := struct {
		Pipeline *processing.Pipeline
	}{
		Pipeline: pipeline,
	}
	mock.lockCreatePipeline.Lock()
	mock.calls.CreatePipeline = append(mock.calls.CreatePipeline, callInfo)
	mock.lockCreatePipeline.Unlock()
	return mock.CreatePipelineFunc(pipeline)
}

// CreatePipelineCalls gets all the calls that were made to CreatePipeline.
// Check the length with:
//
//	len(mockedStore.CreatePipelineCalls())
func (mock *StoreMock) CreatePipelineCalls() []struct {
	Pipeline *processing.Pipeline
} {
	var calls []struct {
		Pipeline *processing.Pipeline
	}
	mock.lockCreatePipeline.RLock()
	calls = mock.calls.CreatePipeline
	mock.lockCreatePipeline.RUnlock()
	return calls
}

// GetPipeline calls GetPipelineFunc.
func (mock *StoreMock) GetPipeline(s string) (*processing.Pipeline, error) {
	if mock.GetPipelineFunc == nil {
		panic("StoreMock.GetPipelineFunc: method is nil but Store.GetPipeline was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockGetPipeline.Lock()
	mock.calls.GetPipeline = append(mock.calls.GetPipeline, callInfo)
	mock.lockGetPipeline.Unlock()
	return mock.GetPipelineFunc(s)
}

// GetPipelineCalls gets all the calls that were made to GetPipeline.
// Check the length with:
//
//	len(mockedStore.GetPipelineCalls())
func (mock *StoreMock) GetPipelineCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockGetPipeline.RLock()
	calls = mock.calls.GetPipeline
	mock.lockGetPipeline.RUnlock()
	return calls
}

// ListPipelines calls ListPipelinesFunc.
func (mock *StoreMock) ListPipelines(pipelinesFilter processing.PipelinesFilter, request pagination.Request) (pagination.Page[processing.Pipeline], error) {
	if mock.ListPipelinesFunc == nil {
		panic("StoreMock.ListPipelinesFunc: method is nil but Store.ListPipelines was just called")
	}
	callInfo := struct {
		PipelinesFilter processing.PipelinesFilter
		Request         pagination.Request
	}{
		PipelinesFilter: pipelinesFilter,
		Request:         request,
	}
	mock.lockListPipelines.Lock()
	mock.calls.ListPipelines = append(mock.calls.ListPipelines, callInfo)
	mock.lockListPipelines.Unlock()
	return mock.ListPipelinesFunc(pipelinesFilter, request)
}

// ListPipelinesCalls gets all the calls that were made to ListPipelines.
// Check the length with:
//
//	len(mockedStore.ListPipelinesCalls())
func (mock *StoreMock) ListPipelinesCalls() []struct {
	PipelinesFilter processing.PipelinesFilter
	Request         pagination.Request
} {
	var calls []struct {
		PipelinesFilter processing.PipelinesFilter
		Request         pagination.Request
	}
	mock.lockListPipelines.RLock()
	calls = mock.calls.ListPipelines
	mock.lockListPipelines.RUnlock()
	return calls
}

// UpdatePipeline calls UpdatePipelineFunc.
func (mock *StoreMock) UpdatePipeline(pipeline *processing.Pipeline) error {
	if mock.UpdatePipelineFunc == nil {
		panic("StoreMock.UpdatePipelineFunc: method is nil but Store.UpdatePipeline was just called")
	}
	callInfo := struct {
		Pipeline *processing.Pipeline
	}{
		Pipeline: pipeline,
	}
	mock.lockUpdatePipeline.Lock()
	mock.calls.UpdatePipeline = append(mock.calls.UpdatePipeline, callInfo)
	mock.lockUpdatePipeline.Unlock()
	return mock.UpdatePipelineFunc(pipeline)
}

// UpdatePipelineCalls gets all the calls that were made to UpdatePipeline.
// Check the length with:
//
//	len(mockedStore.UpdatePipelineCalls())
func (mock *StoreMock) UpdatePipelineCalls() []struct {
	Pipeline *processing.Pipeline
} {
	var calls []struct {
		Pipeline *processing.Pipeline
	}
	mock.lockUpdatePipeline.RLock()
	calls = mock.calls.UpdatePipeline
	mock.lockUpdatePipeline.RUnlock()
	return calls
}

<!-- 
    Pipeline model
    Workers with pagination
 -->

{% import "sensorbucket.nl/sensorbucket/pkg/api" %}
{% func (p *PipelineEditPage) Body() %}
<div class="w-full grid grid-rows-3 grid-cols-5 gap-6">
    <div class="row-span-2 col-span-2 bg-white border rounded-md">
        <header class="border-b py-2 px-4 text-sm text-slate-700">
            Pipeline details
        </header>
        <div class="p-4">
            {%= PipelineDetailBlock(p.Pipeline) %}
        </div>
    </div>
    <div class="row-span-2 col-span-3 bg-white border rounded-md">
        <div class="row-span-2 col-span-2 bg-white border rounded-md">
            <header class="border-b py-2 px-4 text-sm text-slate-700">
                Pipeline steps
            </header>
            <div class="p-4">
                {%= RenderPipelineSteps(p.Pipeline) %}
            </div>
        </div>
    </div>
    <div class="row-span-1 col-span-5 bg-white border rounded-md">
        {%= RenderWorkerTable(p.Workers, p.WorkersNextPage) %}
    </div>
</div>
{% endfunc %}

{% func RenderPipelineSteps(pipeline api.Pipeline) %}
    <script>
        htmx.onLoad(function(content) {
        let sortables = content.querySelectorAll(".sortable");
        const ghostStyles = ['border-dashed', 'border-2', 'border-sky-500', 'bg-white', 'shadow-lg', 'shadow-cyan-500/50'];
        for (var i = 0; i < sortables.length; i++) {
                let sortable = sortables[i];
                let sort = new Sortable(sortable, {
                    animation: 150,

                    // Unfortunately the Sortable JS library does not offer support for multiple classes as the ghost class.
                    // To style it using Tailwind a small hack is required
                    onStart: function(evt) {
                        ghostStyles.forEach((item) => evt.item.classList.add(item));
                    },
                    onEnd: function(evt) {
                        ghostStyles.forEach((item) => evt.item.classList.remove(item));

                        // Update the index for each input item
                        let inputs = sortable.querySelectorAll("input");
                        inputs.forEach((ix, input) => input.value = "stuyffff");
                        for (let i = 0; i < inputs.length; i++) {
                            inputs[i].value = i;
                        }

                        // Now fire the event triggering HTMX to update the pipeline in the backend
                        sortable.dispatchEvent(new Event("steps-updated"));
                    }
                });
            }
        })
    </script>
     <div id="stepsIndicator" class="htmx-indicator w-full h-full flex justify-center">
        <iconify-icon icon="eos-icons:loading" width="15" class="text-secondary-600"></iconify-icon>
    </div>
    <form class="sortable" hx-indicator="#stepsIndicator" hx-post="/pipelines/{%s pipeline.Id %}/steps" hx-trigger="steps-updated">
        {%= RenderPipelineStepsSortable(pipeline.Steps) %}
    </form>
{% endfunc %}

{% func RenderPipelineStepsSortable(steps []string) %}
    {% for ix, step := range steps %}
        <div class="p-4 w-2/4 mt-1.5 text-center mx-auto text-white bg-secondary-600 rounded-lg flex justify-start">
            <input type="hidden" name="{%s step %}" value="{%d ix %}" />
            <p>{%s step %}</p>
        </div>
    {% endfor %}
{% endfunc %}

{% code
type PipelineEditPage struct {
BasePage
Pipeline api.Pipeline
Workers []api.UserWorker
WorkersNextPage string
}
%}
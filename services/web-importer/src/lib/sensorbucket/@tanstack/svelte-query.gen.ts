// This file is auto-generated by @hey-api/openapi-ts

import { type Options, listDevices, createDevice, deleteDevice, getDevice, updateDevice, listDeviceSensors, createDeviceSensor, deleteDeviceSensor, getSensor, updateSensor, listSensors, listSensorGroups, createSensorGroup, deleteSensorGroup, getSensorGroup, updateSensorGroup, addSensorToSensorGroup, deleteSensorFromSensorGroup, queryMeasurements, listDatastreams, getDatastream, listPipelines, createPipeline, disablePipeline, getPipeline, updatePipeline, processUplinkData, listTraces, listIngresses, listWorkers, createWorker, getWorker, updateWorker, getWorkerUserCode, listTenants, addTenantMember, removeTenantMember, updateTenantMember, listApiKeys, createApiKey, revokeApiKey, getApiKey } from '../sdk.gen';
import { queryOptions, infiniteQueryOptions, type InfiniteData, type DefaultError, type MutationOptions } from '@tanstack/svelte-query';
import type { ListDevicesData, ListDevicesResponse, CreateDeviceData, CreateDeviceResponse, DeleteDeviceData, DeleteDeviceResponse, GetDeviceData, UpdateDeviceData, UpdateDeviceResponse, ListDeviceSensorsData, ListDeviceSensorsResponse, CreateDeviceSensorData, CreateDeviceSensorResponse, DeleteDeviceSensorData, DeleteDeviceSensorResponse, GetSensorData, UpdateSensorData, UpdateSensorResponse, ListSensorsData, ListSensorsResponse, ListSensorGroupsData, ListSensorGroupsResponse, CreateSensorGroupData, CreateSensorGroupResponse, DeleteSensorGroupData, DeleteSensorGroupResponse, GetSensorGroupData, UpdateSensorGroupData, UpdateSensorGroupResponse, AddSensorToSensorGroupData, AddSensorToSensorGroupResponse, DeleteSensorFromSensorGroupData, DeleteSensorFromSensorGroupResponse, QueryMeasurementsData, QueryMeasurementsResponse, ListDatastreamsData, ListDatastreamsResponse, GetDatastreamData, ListPipelinesData, ListPipelinesResponse, CreatePipelineData, CreatePipelineResponse, DisablePipelineData, DisablePipelineResponse, GetPipelineData, UpdatePipelineData, UpdatePipelineResponse, ProcessUplinkDataData, ListTracesData, ListTracesError, ListTracesResponse, ListIngressesData, ListIngressesError, ListIngressesResponse, ListWorkersData, ListWorkersError, ListWorkersResponse, CreateWorkerData, CreateWorkerResponse, GetWorkerData, UpdateWorkerData, UpdateWorkerResponse, GetWorkerUserCodeData, ListTenantsData, ListTenantsResponse, AddTenantMemberData, AddTenantMemberError, AddTenantMemberResponse, RemoveTenantMemberData, RemoveTenantMemberError, RemoveTenantMemberResponse, UpdateTenantMemberData, UpdateTenantMemberError, UpdateTenantMemberResponse, ListApiKeysData, ListApiKeysError, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyError, CreateApiKeyResponse, RevokeApiKeyData, RevokeApiKeyError, RevokeApiKeyResponse, GetApiKeyData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const listDevicesQueryKey = (options?: Options<ListDevicesData>) => createQueryKey('listDevices', options);

export const listDevicesOptions = (options?: Options<ListDevicesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDevices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDevicesQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listDevicesInfiniteQueryKey = (options?: Options<ListDevicesData>): QueryKey<Options<ListDevicesData>> => createQueryKey('listDevices', options, true);

export const listDevicesInfiniteOptions = (options?: Options<ListDevicesData>) => {
    return infiniteQueryOptions<ListDevicesResponse, DefaultError, InfiniteData<ListDevicesResponse>, QueryKey<Options<ListDevicesData>>, string | Pick<QueryKey<Options<ListDevicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListDevicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listDevices({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDevicesInfiniteQueryKey(options)
    });
};

export const createDeviceQueryKey = (options?: Options<CreateDeviceData>) => createQueryKey('createDevice', options);

export const createDeviceOptions = (options?: Options<CreateDeviceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDevice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDeviceQueryKey(options)
    });
};

export const createDeviceMutation = (options?: Partial<Options<CreateDeviceData>>) => {
    const mutationOptions: MutationOptions<CreateDeviceResponse, DefaultError, Options<CreateDeviceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDevice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteDeviceMutation = (options?: Partial<Options<DeleteDeviceData>>) => {
    const mutationOptions: MutationOptions<DeleteDeviceResponse, DefaultError, Options<DeleteDeviceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDevice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeviceQueryKey = (options: Options<GetDeviceData>) => createQueryKey('getDevice', options);

export const getDeviceOptions = (options: Options<GetDeviceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDevice({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDeviceQueryKey(options)
    });
};

export const updateDeviceMutation = (options?: Partial<Options<UpdateDeviceData>>) => {
    const mutationOptions: MutationOptions<UpdateDeviceResponse, DefaultError, Options<UpdateDeviceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateDevice({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDeviceSensorsQueryKey = (options: Options<ListDeviceSensorsData>) => createQueryKey('listDeviceSensors', options);

export const listDeviceSensorsOptions = (options: Options<ListDeviceSensorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDeviceSensors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDeviceSensorsQueryKey(options)
    });
};

export const listDeviceSensorsInfiniteQueryKey = (options: Options<ListDeviceSensorsData>): QueryKey<Options<ListDeviceSensorsData>> => createQueryKey('listDeviceSensors', options, true);

export const listDeviceSensorsInfiniteOptions = (options: Options<ListDeviceSensorsData>) => {
    return infiniteQueryOptions<ListDeviceSensorsResponse, DefaultError, InfiniteData<ListDeviceSensorsResponse>, QueryKey<Options<ListDeviceSensorsData>>, string | Pick<QueryKey<Options<ListDeviceSensorsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListDeviceSensorsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listDeviceSensors({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDeviceSensorsInfiniteQueryKey(options)
    });
};

export const createDeviceSensorQueryKey = (options: Options<CreateDeviceSensorData>) => createQueryKey('createDeviceSensor', options);

export const createDeviceSensorOptions = (options: Options<CreateDeviceSensorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createDeviceSensor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createDeviceSensorQueryKey(options)
    });
};

export const createDeviceSensorMutation = (options?: Partial<Options<CreateDeviceSensorData>>) => {
    const mutationOptions: MutationOptions<CreateDeviceSensorResponse, DefaultError, Options<CreateDeviceSensorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createDeviceSensor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteDeviceSensorMutation = (options?: Partial<Options<DeleteDeviceSensorData>>) => {
    const mutationOptions: MutationOptions<DeleteDeviceSensorResponse, DefaultError, Options<DeleteDeviceSensorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteDeviceSensor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSensorQueryKey = (options: Options<GetSensorData>) => createQueryKey('getSensor', options);

export const getSensorOptions = (options: Options<GetSensorData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSensor({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSensorQueryKey(options)
    });
};

export const updateSensorMutation = (options?: Partial<Options<UpdateSensorData>>) => {
    const mutationOptions: MutationOptions<UpdateSensorResponse, DefaultError, Options<UpdateSensorData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSensor({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listSensorsQueryKey = (options?: Options<ListSensorsData>) => createQueryKey('listSensors', options);

export const listSensorsOptions = (options?: Options<ListSensorsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSensors({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSensorsQueryKey(options)
    });
};

export const listSensorsInfiniteQueryKey = (options?: Options<ListSensorsData>): QueryKey<Options<ListSensorsData>> => createQueryKey('listSensors', options, true);

export const listSensorsInfiniteOptions = (options?: Options<ListSensorsData>) => {
    return infiniteQueryOptions<ListSensorsResponse, DefaultError, InfiniteData<ListSensorsResponse>, QueryKey<Options<ListSensorsData>>, string | Pick<QueryKey<Options<ListSensorsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSensorsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSensors({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSensorsInfiniteQueryKey(options)
    });
};

export const listSensorGroupsQueryKey = (options?: Options<ListSensorGroupsData>) => createQueryKey('listSensorGroups', options);

export const listSensorGroupsOptions = (options?: Options<ListSensorGroupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listSensorGroups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSensorGroupsQueryKey(options)
    });
};

export const listSensorGroupsInfiniteQueryKey = (options?: Options<ListSensorGroupsData>): QueryKey<Options<ListSensorGroupsData>> => createQueryKey('listSensorGroups', options, true);

export const listSensorGroupsInfiniteOptions = (options?: Options<ListSensorGroupsData>) => {
    return infiniteQueryOptions<ListSensorGroupsResponse, DefaultError, InfiniteData<ListSensorGroupsResponse>, QueryKey<Options<ListSensorGroupsData>>, string | Pick<QueryKey<Options<ListSensorGroupsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListSensorGroupsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listSensorGroups({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listSensorGroupsInfiniteQueryKey(options)
    });
};

export const createSensorGroupQueryKey = (options?: Options<CreateSensorGroupData>) => createQueryKey('createSensorGroup', options);

export const createSensorGroupOptions = (options?: Options<CreateSensorGroupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createSensorGroup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createSensorGroupQueryKey(options)
    });
};

export const createSensorGroupMutation = (options?: Partial<Options<CreateSensorGroupData>>) => {
    const mutationOptions: MutationOptions<CreateSensorGroupResponse, DefaultError, Options<CreateSensorGroupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createSensorGroup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteSensorGroupMutation = (options?: Partial<Options<DeleteSensorGroupData>>) => {
    const mutationOptions: MutationOptions<DeleteSensorGroupResponse, DefaultError, Options<DeleteSensorGroupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSensorGroup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getSensorGroupQueryKey = (options: Options<GetSensorGroupData>) => createQueryKey('getSensorGroup', options);

export const getSensorGroupOptions = (options: Options<GetSensorGroupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSensorGroup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSensorGroupQueryKey(options)
    });
};

export const updateSensorGroupMutation = (options?: Partial<Options<UpdateSensorGroupData>>) => {
    const mutationOptions: MutationOptions<UpdateSensorGroupResponse, DefaultError, Options<UpdateSensorGroupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateSensorGroup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addSensorToSensorGroupQueryKey = (options: Options<AddSensorToSensorGroupData>) => createQueryKey('addSensorToSensorGroup', options);

export const addSensorToSensorGroupOptions = (options: Options<AddSensorToSensorGroupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addSensorToSensorGroup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addSensorToSensorGroupQueryKey(options)
    });
};

export const addSensorToSensorGroupMutation = (options?: Partial<Options<AddSensorToSensorGroupData>>) => {
    const mutationOptions: MutationOptions<AddSensorToSensorGroupResponse, DefaultError, Options<AddSensorToSensorGroupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addSensorToSensorGroup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteSensorFromSensorGroupMutation = (options?: Partial<Options<DeleteSensorFromSensorGroupData>>) => {
    const mutationOptions: MutationOptions<DeleteSensorFromSensorGroupResponse, DefaultError, Options<DeleteSensorFromSensorGroupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteSensorFromSensorGroup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const queryMeasurementsQueryKey = (options: Options<QueryMeasurementsData>) => createQueryKey('queryMeasurements', options);

export const queryMeasurementsOptions = (options: Options<QueryMeasurementsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await queryMeasurements({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: queryMeasurementsQueryKey(options)
    });
};

export const queryMeasurementsInfiniteQueryKey = (options: Options<QueryMeasurementsData>): QueryKey<Options<QueryMeasurementsData>> => createQueryKey('queryMeasurements', options, true);

export const queryMeasurementsInfiniteOptions = (options: Options<QueryMeasurementsData>) => {
    return infiniteQueryOptions<QueryMeasurementsResponse, DefaultError, InfiniteData<QueryMeasurementsResponse>, QueryKey<Options<QueryMeasurementsData>>, string | Pick<QueryKey<Options<QueryMeasurementsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<QueryMeasurementsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await queryMeasurements({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: queryMeasurementsInfiniteQueryKey(options)
    });
};

export const listDatastreamsQueryKey = (options?: Options<ListDatastreamsData>) => createQueryKey('listDatastreams', options);

export const listDatastreamsOptions = (options?: Options<ListDatastreamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listDatastreams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDatastreamsQueryKey(options)
    });
};

export const listDatastreamsInfiniteQueryKey = (options?: Options<ListDatastreamsData>): QueryKey<Options<ListDatastreamsData>> => createQueryKey('listDatastreams', options, true);

export const listDatastreamsInfiniteOptions = (options?: Options<ListDatastreamsData>) => {
    return infiniteQueryOptions<ListDatastreamsResponse, DefaultError, InfiniteData<ListDatastreamsResponse>, QueryKey<Options<ListDatastreamsData>>, string | Pick<QueryKey<Options<ListDatastreamsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListDatastreamsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listDatastreams({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listDatastreamsInfiniteQueryKey(options)
    });
};

export const getDatastreamQueryKey = (options: Options<GetDatastreamData>) => createQueryKey('getDatastream', options);

export const getDatastreamOptions = (options: Options<GetDatastreamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDatastream({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDatastreamQueryKey(options)
    });
};

export const listPipelinesQueryKey = (options?: Options<ListPipelinesData>) => createQueryKey('listPipelines', options);

export const listPipelinesOptions = (options?: Options<ListPipelinesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listPipelines({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPipelinesQueryKey(options)
    });
};

export const listPipelinesInfiniteQueryKey = (options?: Options<ListPipelinesData>): QueryKey<Options<ListPipelinesData>> => createQueryKey('listPipelines', options, true);

export const listPipelinesInfiniteOptions = (options?: Options<ListPipelinesData>) => {
    return infiniteQueryOptions<ListPipelinesResponse, DefaultError, InfiniteData<ListPipelinesResponse>, QueryKey<Options<ListPipelinesData>>, string | Pick<QueryKey<Options<ListPipelinesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListPipelinesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listPipelines({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listPipelinesInfiniteQueryKey(options)
    });
};

export const createPipelineQueryKey = (options?: Options<CreatePipelineData>) => createQueryKey('createPipeline', options);

export const createPipelineOptions = (options?: Options<CreatePipelineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPipeline({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPipelineQueryKey(options)
    });
};

export const createPipelineMutation = (options?: Partial<Options<CreatePipelineData>>) => {
    const mutationOptions: MutationOptions<CreatePipelineResponse, DefaultError, Options<CreatePipelineData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPipeline({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const disablePipelineMutation = (options?: Partial<Options<DisablePipelineData>>) => {
    const mutationOptions: MutationOptions<DisablePipelineResponse, DefaultError, Options<DisablePipelineData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disablePipeline({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPipelineQueryKey = (options: Options<GetPipelineData>) => createQueryKey('getPipeline', options);

export const getPipelineOptions = (options: Options<GetPipelineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPipeline({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPipelineQueryKey(options)
    });
};

export const updatePipelineMutation = (options?: Partial<Options<UpdatePipelineData>>) => {
    const mutationOptions: MutationOptions<UpdatePipelineResponse, DefaultError, Options<UpdatePipelineData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePipeline({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const processUplinkDataQueryKey = (options: Options<ProcessUplinkDataData>) => createQueryKey('processUplinkData', options);

export const processUplinkDataOptions = (options: Options<ProcessUplinkDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await processUplinkData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: processUplinkDataQueryKey(options)
    });
};

export const processUplinkDataMutation = (options?: Partial<Options<ProcessUplinkDataData>>) => {
    const mutationOptions: MutationOptions<unknown, DefaultError, Options<ProcessUplinkDataData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await processUplinkData({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTracesQueryKey = (options?: Options<ListTracesData>) => createQueryKey('listTraces', options);

export const listTracesOptions = (options?: Options<ListTracesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTraces({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTracesQueryKey(options)
    });
};

export const listTracesInfiniteQueryKey = (options?: Options<ListTracesData>): QueryKey<Options<ListTracesData>> => createQueryKey('listTraces', options, true);

export const listTracesInfiniteOptions = (options?: Options<ListTracesData>) => {
    return infiniteQueryOptions<ListTracesResponse, ListTracesError, InfiniteData<ListTracesResponse>, QueryKey<Options<ListTracesData>>, string | Pick<QueryKey<Options<ListTracesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTracesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTraces({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTracesInfiniteQueryKey(options)
    });
};

export const listIngressesQueryKey = (options?: Options<ListIngressesData>) => createQueryKey('listIngresses', options);

export const listIngressesOptions = (options?: Options<ListIngressesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listIngresses({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listIngressesQueryKey(options)
    });
};

export const listIngressesInfiniteQueryKey = (options?: Options<ListIngressesData>): QueryKey<Options<ListIngressesData>> => createQueryKey('listIngresses', options, true);

export const listIngressesInfiniteOptions = (options?: Options<ListIngressesData>) => {
    return infiniteQueryOptions<ListIngressesResponse, ListIngressesError, InfiniteData<ListIngressesResponse>, QueryKey<Options<ListIngressesData>>, string | Pick<QueryKey<Options<ListIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListIngressesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listIngresses({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listIngressesInfiniteQueryKey(options)
    });
};

export const listWorkersQueryKey = (options?: Options<ListWorkersData>) => createQueryKey('listWorkers', options);

export const listWorkersOptions = (options?: Options<ListWorkersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listWorkers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWorkersQueryKey(options)
    });
};

export const listWorkersInfiniteQueryKey = (options?: Options<ListWorkersData>): QueryKey<Options<ListWorkersData>> => createQueryKey('listWorkers', options, true);

export const listWorkersInfiniteOptions = (options?: Options<ListWorkersData>) => {
    return infiniteQueryOptions<ListWorkersResponse, ListWorkersError, InfiniteData<ListWorkersResponse>, QueryKey<Options<ListWorkersData>>, string | Pick<QueryKey<Options<ListWorkersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListWorkersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listWorkers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listWorkersInfiniteQueryKey(options)
    });
};

export const createWorkerQueryKey = (options?: Options<CreateWorkerData>) => createQueryKey('createWorker', options);

export const createWorkerOptions = (options?: Options<CreateWorkerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createWorker({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createWorkerQueryKey(options)
    });
};

export const createWorkerMutation = (options?: Partial<Options<CreateWorkerData>>) => {
    const mutationOptions: MutationOptions<CreateWorkerResponse, DefaultError, Options<CreateWorkerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createWorker({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkerQueryKey = (options: Options<GetWorkerData>) => createQueryKey('getWorker', options);

export const getWorkerOptions = (options: Options<GetWorkerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorker({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkerQueryKey(options)
    });
};

export const updateWorkerMutation = (options?: Partial<Options<UpdateWorkerData>>) => {
    const mutationOptions: MutationOptions<UpdateWorkerResponse, DefaultError, Options<UpdateWorkerData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateWorker({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkerUserCodeQueryKey = (options: Options<GetWorkerUserCodeData>) => createQueryKey('getWorkerUserCode', options);

export const getWorkerUserCodeOptions = (options: Options<GetWorkerUserCodeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getWorkerUserCode({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getWorkerUserCodeQueryKey(options)
    });
};

export const listTenantsQueryKey = (options?: Options<ListTenantsData>) => createQueryKey('listTenants', options);

export const listTenantsOptions = (options?: Options<ListTenantsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTenants({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTenantsQueryKey(options)
    });
};

export const listTenantsInfiniteQueryKey = (options?: Options<ListTenantsData>): QueryKey<Options<ListTenantsData>> => createQueryKey('listTenants', options, true);

export const listTenantsInfiniteOptions = (options?: Options<ListTenantsData>) => {
    return infiniteQueryOptions<ListTenantsResponse, DefaultError, InfiniteData<ListTenantsResponse>, QueryKey<Options<ListTenantsData>>, string | Pick<QueryKey<Options<ListTenantsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTenantsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTenants({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTenantsInfiniteQueryKey(options)
    });
};

export const addTenantMemberQueryKey = (options: Options<AddTenantMemberData>) => createQueryKey('addTenantMember', options);

export const addTenantMemberOptions = (options: Options<AddTenantMemberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTenantMember({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTenantMemberQueryKey(options)
    });
};

export const addTenantMemberMutation = (options?: Partial<Options<AddTenantMemberData>>) => {
    const mutationOptions: MutationOptions<AddTenantMemberResponse, AddTenantMemberError, Options<AddTenantMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTenantMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTenantMemberMutation = (options?: Partial<Options<RemoveTenantMemberData>>) => {
    const mutationOptions: MutationOptions<RemoveTenantMemberResponse, RemoveTenantMemberError, Options<RemoveTenantMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTenantMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateTenantMemberMutation = (options?: Partial<Options<UpdateTenantMemberData>>) => {
    const mutationOptions: MutationOptions<UpdateTenantMemberResponse, UpdateTenantMemberError, Options<UpdateTenantMemberData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTenantMember({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listApiKeysQueryKey = (options?: Options<ListApiKeysData>) => createQueryKey('listApiKeys', options);

export const listApiKeysOptions = (options?: Options<ListApiKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listApiKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysQueryKey(options)
    });
};

export const listApiKeysInfiniteQueryKey = (options?: Options<ListApiKeysData>): QueryKey<Options<ListApiKeysData>> => createQueryKey('listApiKeys', options, true);

export const listApiKeysInfiniteOptions = (options?: Options<ListApiKeysData>) => {
    return infiniteQueryOptions<ListApiKeysResponse, ListApiKeysError, InfiniteData<ListApiKeysResponse>, QueryKey<Options<ListApiKeysData>>, string | Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListApiKeysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    cursor: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listApiKeys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listApiKeysInfiniteQueryKey(options)
    });
};

export const createApiKeyQueryKey = (options?: Options<CreateApiKeyData>) => createQueryKey('createApiKey', options);

export const createApiKeyOptions = (options?: Options<CreateApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createApiKeyQueryKey(options)
    });
};

export const createApiKeyMutation = (options?: Partial<Options<CreateApiKeyData>>) => {
    const mutationOptions: MutationOptions<CreateApiKeyResponse, CreateApiKeyError, Options<CreateApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const revokeApiKeyMutation = (options?: Partial<Options<RevokeApiKeyData>>) => {
    const mutationOptions: MutationOptions<RevokeApiKeyResponse, RevokeApiKeyError, Options<RevokeApiKeyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await revokeApiKey({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiKeyQueryKey = (options: Options<GetApiKeyData>) => createQueryKey('getApiKey', options);

export const getApiKeyOptions = (options: Options<GetApiKeyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiKey({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiKeyQueryKey(options)
    });
};
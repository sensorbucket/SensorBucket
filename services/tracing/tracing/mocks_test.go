// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package tracing

import (
	"sensorbucket.nl/sensorbucket/internal/pagination"
	"sync"
)

// Ensure, that StepStoreMock does implement StepStore.
// If this is not the case, regenerate this file with moq.
var _ StepStore = &StepStoreMock{}

// StepStoreMock is a mock implementation of StepStore.
//
//	func TestSomethingThatUsesStepStore(t *testing.T) {
//
//		// make and configure a mocked StepStore
//		mockedStepStore := &StepStoreMock{
//			GetStepsByTracingIDsFunc: func(strings []string) ([]EnrichedStep, error) {
//				panic("mock out the GetStepsByTracingIDs method")
//			},
//			QueryTracesFunc: func(filter Filter, r pagination.Request) (*pagination.Page[string], error) {
//				panic("mock out the QueryTraces method")
//			},
//			UpsertStepFunc: func(step Step, withError bool) error {
//				panic("mock out the UpsertStep method")
//			},
//		}
//
//		// use mockedStepStore in code that requires StepStore
//		// and then make assertions.
//
//	}
type StepStoreMock struct {
	// GetStepsByTracingIDsFunc mocks the GetStepsByTracingIDs method.
	GetStepsByTracingIDsFunc func(strings []string) ([]EnrichedStep, error)

	// QueryTracesFunc mocks the QueryTraces method.
	QueryTracesFunc func(filter Filter, r pagination.Request) (*pagination.Page[string], error)

	// UpsertStepFunc mocks the UpsertStep method.
	UpsertStepFunc func(step Step, withError bool) error

	// calls tracks calls to the methods.
	calls struct {
		// GetStepsByTracingIDs holds details about calls to the GetStepsByTracingIDs method.
		GetStepsByTracingIDs []struct {
			// Strings is the strings argument value.
			Strings []string
		}
		// QueryTraces holds details about calls to the QueryTraces method.
		QueryTraces []struct {
			// Filter is the filter argument value.
			Filter Filter
			// R is the r argument value.
			R pagination.Request
		}
		// UpsertStep holds details about calls to the UpsertStep method.
		UpsertStep []struct {
			// Step is the step argument value.
			Step Step
			// WithError is the withError argument value.
			WithError bool
		}
	}
	lockGetStepsByTracingIDs sync.RWMutex
	lockQueryTraces          sync.RWMutex
	lockUpsertStep           sync.RWMutex
}

// GetStepsByTracingIDs calls GetStepsByTracingIDsFunc.
func (mock *StepStoreMock) GetStepsByTracingIDs(strings []string) ([]EnrichedStep, error) {
	if mock.GetStepsByTracingIDsFunc == nil {
		panic("StepStoreMock.GetStepsByTracingIDsFunc: method is nil but StepStore.GetStepsByTracingIDs was just called")
	}
	callInfo := struct {
		Strings []string
	}{
		Strings: strings,
	}
	mock.lockGetStepsByTracingIDs.Lock()
	mock.calls.GetStepsByTracingIDs = append(mock.calls.GetStepsByTracingIDs, callInfo)
	mock.lockGetStepsByTracingIDs.Unlock()
	return mock.GetStepsByTracingIDsFunc(strings)
}

// GetStepsByTracingIDsCalls gets all the calls that were made to GetStepsByTracingIDs.
// Check the length with:
//
//	len(mockedStepStore.GetStepsByTracingIDsCalls())
func (mock *StepStoreMock) GetStepsByTracingIDsCalls() []struct {
	Strings []string
} {
	var calls []struct {
		Strings []string
	}
	mock.lockGetStepsByTracingIDs.RLock()
	calls = mock.calls.GetStepsByTracingIDs
	mock.lockGetStepsByTracingIDs.RUnlock()
	return calls
}

// QueryTraces calls QueryTracesFunc.
func (mock *StepStoreMock) QueryTraces(filter Filter, r pagination.Request) (*pagination.Page[string], error) {
	if mock.QueryTracesFunc == nil {
		panic("StepStoreMock.QueryTracesFunc: method is nil but StepStore.QueryTraces was just called")
	}
	callInfo := struct {
		Filter Filter
		R      pagination.Request
	}{
		Filter: filter,
		R:      r,
	}
	mock.lockQueryTraces.Lock()
	mock.calls.QueryTraces = append(mock.calls.QueryTraces, callInfo)
	mock.lockQueryTraces.Unlock()
	return mock.QueryTracesFunc(filter, r)
}

// QueryTracesCalls gets all the calls that were made to QueryTraces.
// Check the length with:
//
//	len(mockedStepStore.QueryTracesCalls())
func (mock *StepStoreMock) QueryTracesCalls() []struct {
	Filter Filter
	R      pagination.Request
} {
	var calls []struct {
		Filter Filter
		R      pagination.Request
	}
	mock.lockQueryTraces.RLock()
	calls = mock.calls.QueryTraces
	mock.lockQueryTraces.RUnlock()
	return calls
}

// UpsertStep calls UpsertStepFunc.
func (mock *StepStoreMock) UpsertStep(step Step, withError bool) error {
	if mock.UpsertStepFunc == nil {
		panic("StepStoreMock.UpsertStepFunc: method is nil but StepStore.UpsertStep was just called")
	}
	callInfo := struct {
		Step      Step
		WithError bool
	}{
		Step:      step,
		WithError: withError,
	}
	mock.lockUpsertStep.Lock()
	mock.calls.UpsertStep = append(mock.calls.UpsertStep, callInfo)
	mock.lockUpsertStep.Unlock()
	return mock.UpsertStepFunc(step, withError)
}

// UpsertStepCalls gets all the calls that were made to UpsertStep.
// Check the length with:
//
//	len(mockedStepStore.UpsertStepCalls())
func (mock *StepStoreMock) UpsertStepCalls() []struct {
	Step      Step
	WithError bool
} {
	var calls []struct {
		Step      Step
		WithError bool
	}
	mock.lockUpsertStep.RLock()
	calls = mock.calls.UpsertStep
	mock.lockUpsertStep.RUnlock()
	return calls
}
